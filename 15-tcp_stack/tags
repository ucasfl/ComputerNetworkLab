!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARPHRD_ETHER	./include/arp.h	8;"	d
ARPOP_REPLY	./include/arp.h	11;"	d
ARPOP_REQUEST	./include/arp.h	10;"	d
ARP_ENTRY_TIMEOUT	./include/arpcache.h	11;"	d
ARP_REQUEST_MAX_RETRIES	./include/arpcache.h	12;"	d
BE_IP_FMT_STR	./include/ip.h	61;"	d
DEBUG	./include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
DEFAULT_TTL	./include/ip.h	45;"	d
ERROR	./include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
ETHER_HDR_SIZE	./include/ether.h	20;"	d
ETH_ALEN	./include/ether.h	6;"	d
ETH_FRAME_LEN	./include/ether.h	7;"	d
ETH_P_ALL	./include/ether.h	10;"	d
ETH_P_ARP	./include/ether.h	12;"	d
ETH_P_IP	./include/ether.h	11;"	d
HASH_16BITS	./include/hash.h	7;"	d
HASH_8BITS	./include/hash.h	6;"	d
HOST_IP_FMT_STR	./include/ip.h	69;"	d
HOST_IP_FMT_STR	./include/ip.h	71;"	d
ICMP_COPIED_DATA_LEN	./include/icmp.h	17;"	d
ICMP_DEST_UNREACH	./include/icmp.h	21;"	d
ICMP_ECHOREPLY	./include/icmp.h	20;"	d
ICMP_ECHOREQUEST	./include/icmp.h	19;"	d
ICMP_EXC_TTL	./include/icmp.h	29;"	d
ICMP_HDR_SIZE	./include/icmp.h	16;"	d
ICMP_HOST_UNREACH	./include/icmp.h	26;"	d
ICMP_NET_UNREACH	./include/icmp.h	25;"	d
ICMP_TIME_EXCEEDED	./include/icmp.h	22;"	d
INFO	./include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
IPPROTO_ICMP	./include/ip.h	13;"	d
IPPROTO_OSPFv2	./include/ip.h	24;"	d
IPPROTO_TCP	./include/ip.h	17;"	d
IPPROTO_UDP	./include/ip.h	21;"	d
IP_BASE_HDR_SIZE	./include/ip.h	48;"	d
IP_DATA	./include/ip.h	50;"	d
IP_DF	./include/ip.h	46;"	d
IP_FMT	./include/ip.h	55;"	d
IP_HDR_SIZE	./include/ip.h	49;"	d
LE_IP_FMT_STR	./include/ip.h	56;"	d
MAX_ARP_SIZE	./include/arpcache.h	10;"	d
NET_IP_FMT_STR	./include/ip.h	66;"	d
PORT_MAX	./include/tcp_sock.h	15;"	d
PORT_MIN	./include/tcp_sock.h	14;"	d
ROUTE_BATCH_SIZE	rtable_internal.c	15;"	d	file:
TCP_ACK	./include/tcp.h	28;"	d
TCP_BASE_HDR_SIZE	./include/tcp.h	36;"	d
TCP_CLOSED	./include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_CLOSE_WAIT	./include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_CLOSING	./include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_DEFAULT_WINDOW	./include/tcp.h	39;"	d
TCP_ESTABLISHED	./include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_FIN	./include/tcp.h	24;"	d
TCP_FIN_WAIT_1	./include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_FIN_WAIT_2	./include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_HASH_MASK	./include/tcp_hash.h	9;"	d
TCP_HASH_SIZE	./include/tcp_hash.h	8;"	d
TCP_HDR_OFFSET	./include/tcp.h	35;"	d
TCP_HDR_SIZE	./include/tcp.h	37;"	d
TCP_LAST_ACK	./include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_LISTEN	./include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_MAX_BACKLOG	./include/tcp_sock.h	56;"	d
TCP_MSL	./include/tcp_timer.h	19;"	d
TCP_PSH	./include/tcp.h	27;"	d
TCP_RST	./include/tcp.h	26;"	d
TCP_SYN	./include/tcp.h	25;"	d
TCP_SYN_RECV	./include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_SYN_SENT	./include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_TIMER_SCAN_INTERVAL	./include/tcp_timer.h	18;"	d
TCP_TIMEWAIT_TIMEOUT	./include/tcp_timer.h	20;"	d
TCP_TIME_WAIT	./include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_URG	./include/tcp.h	29;"	d
WARNING	./include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
__ARPCACHE_H__	./include/arpcache.h	2;"	d
__ARP_H__	./include/arp.h	2;"	d
__ASYNC_WAIT_H__	./include/async_wait.h	2;"	d
__BASE_H__	./include/base.h	2;"	d
__CHECKSUM_H__	./include/checksum.h	2;"	d
__ETHER_H__	./include/ether.h	2;"	d
__HASH_H__	./include/hash.h	2;"	d
__ICMP_H__	./include/icmp.h	2;"	d
__IP_H__	./include/ip.h	2;"	d
__LIST_H__	./include/list.h	2;"	d
__LOG_H__	./include/log.h	2;"	d
__PACKET_H__	./include/packet.h	2;"	d
__RING_BUFFER_H__	./include/ring_buffer.h	2;"	d
__RTABLE_H__	./include/rtable.h	2;"	d
__SYNCH_WAIT_H__	./include/synch_wait.h	2;"	d
__TCP_APPS_H__	./include/tcp_apps.h	2;"	d
__TCP_HASH_H__	./include/tcp_hash.h	2;"	d
__TCP_H__	./include/tcp.h	2;"	d
__TCP_SOCK_H__	./include/tcp_sock.h	2;"	d
__TCP_TIMER_H__	./include/tcp_timer.h	2;"	d
__TYPES_H__	./include/types.h	2;"	d
_iface_send_packet	packet.c	/^void _iface_send_packet(iface_info_t *iface, char *packet, int len)$/;"	f
accept_backlog	./include/tcp_sock.h	/^	int accept_backlog;$/;"	m	struct:tcp_sock
accept_queue	./include/tcp_sock.h	/^	struct list_head accept_queue;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
ack	./include/tcp.h	/^	u32 ack;			\/\/ acknowledgement number$/;"	m	struct:tcphdr
ack	./include/tcp.h	/^	u32 ack;		\/\/ ack number in tcp header$/;"	m	struct:tcp_cb
add_rt_entry	rtable.c	/^void add_rt_entry(rt_entry_t *entry)$/;"	f
added	./include/arpcache.h	/^	time_t added;		\/\/ the time when this entry is inserted$/;"	m	struct:arp_cache_entry
alloc_ring_buffer	./include/ring_buffer.h	/^static inline struct ring_buffer *alloc_ring_buffer(int size)$/;"	f
alloc_tcp_sock	tcp_sock.c	/^struct tcp_sock *alloc_tcp_sock()$/;"	f
alloc_wait_struct	./include/async_wait.h	/^static inline struct async_wait *alloc_wait_struct()$/;"	f
alloc_wait_struct	./include/synch_wait.h	/^static inline struct synch_wait *alloc_wait_struct()$/;"	f
arp_cache_entry	./include/arpcache.h	/^struct arp_cache_entry {$/;"	s
arp_hln	./include/arp.h	/^    u8	arp_hln;		\/\/ length of hardware address, should be 6$/;"	m	struct:ether_arp
arp_hrd	./include/arp.h	/^    u16 arp_hrd;		\/\/ format of hardware address, should be 0x01$/;"	m	struct:ether_arp
arp_op	./include/arp.h	/^    u16 arp_op;			\/\/ ARP opcode (command)$/;"	m	struct:ether_arp
arp_pln	./include/arp.h	/^    u8	arp_pln;		\/\/ length of protocol address, should be 4$/;"	m	struct:ether_arp
arp_pro	./include/arp.h	/^    u16 arp_pro;		\/\/ format of protocol address, should be 0x0800$/;"	m	struct:ether_arp
arp_req	./include/arpcache.h	/^struct arp_req {$/;"	s
arp_send_reply	arp.c	/^void arp_send_reply(iface_info_t *iface, struct ether_arp *req_hdr)$/;"	f
arp_send_request	arp.c	/^void arp_send_request(iface_info_t *iface, u32 dst_ip)$/;"	f
arp_sha	./include/arp.h	/^	u8	arp_sha[ETH_ALEN];	\/\/ sender hardware address$/;"	m	struct:ether_arp
arp_spa	./include/arp.h	/^	u32	arp_spa;		\/\/ sender protocol address$/;"	m	struct:ether_arp
arp_tha	./include/arp.h	/^	u8	arp_tha[ETH_ALEN];	\/\/ target hardware address$/;"	m	struct:ether_arp
arp_tpa	./include/arp.h	/^	u32	arp_tpa;		\/\/ target protocol address$/;"	m	struct:ether_arp
arpcache	arpcache.c	/^static arpcache_t arpcache;$/;"	v	file:
arpcache_append_packet	arpcache.c	/^void arpcache_append_packet(iface_info_t *iface, u32 ip4, char *packet, int len)$/;"	f
arpcache_destroy	arpcache.c	/^void arpcache_destroy()$/;"	f
arpcache_init	arpcache.c	/^void arpcache_init()$/;"	f
arpcache_insert	arpcache.c	/^void arpcache_insert(u32 ip4, u8 mac[ETH_ALEN])$/;"	f
arpcache_lookup	arpcache.c	/^int arpcache_lookup(u32 ip4, u8 mac[ETH_ALEN])$/;"	f
arpcache_sweep	arpcache.c	/^void *arpcache_sweep(void *arg) $/;"	f
arpcache_t	./include/arpcache.h	/^} arpcache_t;$/;"	t	typeref:struct:__anon2
async_wait	./include/async_wait.h	/^struct async_wait {$/;"	s
backlog	./include/tcp_sock.h	/^	int backlog;$/;"	m	struct:tcp_sock
bind_hash_list	./include/tcp_sock.h	/^	struct list_head bind_hash_list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
bind_table	./include/tcp_hash.h	/^	struct list_head bind_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
broadcast_packet	packet.c	/^void broadcast_packet(iface_info_t *in_iface, char *packet, int len)$/;"	f
buf	./include/ring_buffer.h	/^	char buf[0];$/;"	m	struct:ring_buffer
buf	rtable_internal.c	/^	char buf[ROUTE_BATCH_SIZE];$/;"	m	struct:__anon1	file:
cached_packets	./include/arpcache.h	/^	struct list_head cached_packets;	\/\/ pending packets$/;"	m	struct:arp_req	typeref:struct:arp_req::list_head
cached_pkt	./include/arpcache.h	/^struct cached_pkt {$/;"	s
checksum	./include/checksum.h	/^static inline u16 checksum(u16 *buf, int nbytes, u32 sum)$/;"	f
checksum	./include/icmp.h	/^	u16	checksum;			$/;"	m	struct:icmphdr
checksum	./include/ip.h	/^    u16 checksum;						\/\/ checksum of ip header$/;"	m	struct:iphdr
checksum	./include/tcp.h	/^	u16 checksum;		\/\/ checksum$/;"	m	struct:tcphdr
clear_rtable	rtable.c	/^void clear_rtable()$/;"	f
code	./include/icmp.h	/^	u8	code;				\/\/ icmp code$/;"	m	struct:icmphdr
cond	./include/async_wait.h	/^	pthread_cond_t cond;$/;"	m	struct:async_wait
cond	./include/synch_wait.h	/^	pthread_cond_t cond;		\/\/ condition variable to synch$/;"	m	struct:synch_wait
copy_flag_str	tcp.c	/^static int copy_flag_str(u8 flags, int flag, char *buf, int start, $/;"	f	file:
daddr	./include/ip.h	/^    u32 daddr;							\/\/ destination ip address$/;"	m	struct:iphdr
daddr	./include/tcp.h	/^	u32 daddr;		\/\/ source port of the packet$/;"	m	struct:tcp_cb
dead	./include/async_wait.h	/^	int dead;$/;"	m	struct:async_wait
dead	./include/synch_wait.h	/^	int dead;					\/\/ whether dead$/;"	m	struct:synch_wait
dest	./include/rtable.h	/^	u32 dest;				\/\/ destination ip address (could be network or host)$/;"	m	struct:__anon5
dport	./include/tcp.h	/^	u16 dport;		\/\/ dest port of the packet$/;"	m	struct:tcp_cb
dport	./include/tcp.h	/^	u16 dport;		\/\/ destination port$/;"	m	struct:tcphdr
entries	./include/arpcache.h	/^	struct arp_cache_entry entries[MAX_ARP_SIZE];	\/\/ IP->max mapping entries$/;"	m	struct:__anon2	typeref:struct:__anon2::arp_cache_entry
established_table	./include/tcp_hash.h	/^	struct list_head established_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
ether_arp	./include/arp.h	/^struct ether_arp {$/;"	s
ether_dhost	./include/ether.h	/^	u8 ether_dhost[ETH_ALEN];			\/\/ destination mac address$/;"	m	struct:ether_header
ether_header	./include/ether.h	/^struct ether_header {$/;"	s
ether_shost	./include/ether.h	/^	u8 ether_shost[ETH_ALEN];			\/\/ source mac address$/;"	m	struct:ether_header
ether_type	./include/ether.h	/^	u16 ether_type;						\/\/ protocol format$/;"	m	struct:ether_header
fd	./include/base.h	/^	int fd;						\/\/ file descriptor for receiving & sending $/;"	m	struct:__anon4
fd_to_iface	main.c	/^static iface_info_t *fd_to_iface(int fd)$/;"	f	file:
fds	./include/base.h	/^	struct pollfd *fds;				\/\/ structure used to poll packets among $/;"	m	struct:__anon3	typeref:struct:__anon3::pollfd
find_available_ifaces	main.c	/^static void find_available_ifaces()$/;"	f	file:
flags	./include/rtable.h	/^	int flags;				\/\/ flags (could be omitted here)$/;"	m	struct:__anon5
flags	./include/tcp.h	/^	u8 flags;		\/\/ flags in tcp header$/;"	m	struct:tcp_cb
flags	./include/tcp.h	/^	u8 flags;$/;"	m	struct:tcphdr
frag_off	./include/ip.h	/^    u16 frag_off;						\/\/ the offset of ip fragment$/;"	m	struct:iphdr
free_ring_buffer	./include/ring_buffer.h	/^static inline void free_ring_buffer(struct ring_buffer *rbuf)$/;"	f
free_tcp_sock	tcp_sock.c	/^void free_tcp_sock(struct tcp_sock *tsk)$/;"	f
free_wait_struct	./include/async_wait.h	/^static inline void free_wait_struct(struct async_wait *wait)$/;"	f
free_wait_struct	./include/synch_wait.h	/^static inline void free_wait_struct(struct synch_wait *wait)$/;"	f
get_next_hop	rtable.c	/^u32 get_next_hop(rt_entry_t *entry, u32 dst)$/;"	f
get_unparsed_route_info	rtable_internal.c	/^static int get_unparsed_route_info(char *buf, int size)$/;"	f	file:
gw	./include/rtable.h	/^	u32 gw;					\/\/ ip address of next hop (will be 0 if dest is in $/;"	m	struct:__anon5
handle_arp_packet	arp.c	/^void handle_arp_packet(iface_info_t *iface, char *packet, int len)$/;"	f
handle_ip_packet	ip.c	/^void handle_ip_packet(iface_info_t *iface, char *packet, int len)$/;"	f
handle_packet	main.c	/^void handle_packet(iface_info_t *iface, char *packet, int len)$/;"	f
handle_tcp_packet	tcp.c	/^void handle_tcp_packet(char *packet, struct iphdr *ip, struct tcphdr *tcp)$/;"	f
hash16	./include/hash.h	/^static inline u16 hash16(char *buf, int len)$/;"	f
hash8	./include/hash.h	/^static inline u8 hash8(char *buf, int len)$/;"	f
hash_list	./include/tcp_sock.h	/^	struct list_head hash_list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
head	./include/ring_buffer.h	/^	int head;		\/\/ read from head$/;"	m	struct:ring_buffer
icmp_checksum	./include/icmp.h	/^static inline u16 icmp_checksum(struct icmphdr *icmp, int len)$/;"	f
icmp_identifier	./include/icmp.h	/^	u16 icmp_identifier;	\/\/ icmp identifier, used in icmp echo request$/;"	m	struct:icmphdr
icmp_send_packet	icmp.c	/^void icmp_send_packet(const char *in_pkt, int len, u8 type, u8 code)$/;"	f
icmp_sequence	./include/icmp.h	/^	u16 icmp_sequence;		\/\/ icmp sequence, used in icmp echo request$/;"	m	struct:icmphdr
icmphdr	./include/icmp.h	/^struct icmphdr {$/;"	s
id	./include/ip.h	/^    u16 id;								\/\/ ip identifier$/;"	m	struct:iphdr
if_index_to_name	rtable_internal.c	/^static void if_index_to_name(int if_index, char *if_name)$/;"	f	file:
if_name	./include/rtable.h	/^	char if_name[16];		\/\/ name of the interface$/;"	m	struct:__anon5
if_name_to_iface	rtable_internal.c	/^static iface_info_t *if_name_to_iface(const char *if_name)$/;"	f	file:
iface	./include/arpcache.h	/^	iface_info_t *iface;	\/\/ the interface that will send the pending packets$/;"	m	struct:arp_req
iface	./include/rtable.h	/^	iface_info_t *iface;	\/\/ pointer to the interface structure$/;"	m	struct:__anon5
iface_info_t	./include/base.h	/^} iface_info_t;$/;"	t	typeref:struct:__anon4
iface_list	./include/base.h	/^	struct list_head iface_list;	\/\/ the list of interfaces$/;"	m	struct:__anon3	typeref:struct:__anon3::list_head
iface_send_packet	packet.c	/^void iface_send_packet(iface_info_t *iface, char *packet, int len)$/;"	f
iface_send_packet_by_arp	arp.c	/^void iface_send_packet_by_arp(iface_info_t *iface, u32 dst_ip, char *packet, int len)$/;"	f
ihl	./include/ip.h	/^    unsigned int ihl:4;					\/\/ length of ip header$/;"	m	struct:iphdr
index	./include/base.h	/^	int index;					\/\/ the index (unique ID) of this interface$/;"	m	struct:__anon4
init_all_ifaces	main.c	/^void init_all_ifaces()$/;"	f
init_list_head	./include/list.h	/^static inline void init_list_head(struct list_head *list)$/;"	f
init_rtable	rtable.c	/^void init_rtable()$/;"	f
init_tcp_stack	tcp_sock.c	/^void init_tcp_stack()$/;"	f
init_ustack	main.c	/^void init_ustack()$/;"	f
instance	main.c	/^ustack_t *instance;$/;"	v
ip	./include/base.h	/^	u32 ip;						\/\/ ip address of this interface$/;"	m	struct:__anon4
ip	./include/tcp.h	/^	struct iphdr *ip;		\/\/ pointer to ip header$/;"	m	struct:tcp_cb	typeref:struct:tcp_cb::iphdr
ip	./include/tcp_sock.h	/^	u32 ip;$/;"	m	struct:sock_addr
ip4	./include/arpcache.h	/^	u32 ip4;				\/\/ destination ip address$/;"	m	struct:arp_req
ip4	./include/arpcache.h	/^	u32 ip4; 			\/\/ destination ip address, stored in host byte order$/;"	m	struct:arp_cache_entry
ip_checksum	./include/ip.h	/^static inline u16 ip_checksum(struct iphdr *hdr)$/;"	f
ip_forward_packet	ip.c	/^void ip_forward_packet(u32 ip_dst, char *packet, int len)$/;"	f
ip_init_hdr	ip.c	/^void ip_init_hdr(struct iphdr *ip, u32 saddr, u32 daddr, u16 len, u8 proto)$/;"	f
ip_send_packet	ip.c	/^void ip_send_packet(char *packet, int len)$/;"	f
ip_str	./include/base.h	/^	char ip_str[16];			\/\/ string of the ip address$/;"	m	struct:__anon4
iphdr	./include/ip.h	/^struct iphdr {$/;"	s
is_tcp_seq_valid	tcp_in.c	/^static inline int is_tcp_seq_valid(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
iss	./include/tcp_sock.h	/^	u32 iss;$/;"	m	struct:tcp_sock
len	./include/arpcache.h	/^	int len;				\/\/ the length of packet$/;"	m	struct:cached_pkt
list	./include/arpcache.h	/^	struct list_head list;	$/;"	m	struct:arp_req	typeref:struct:arp_req::list_head
list	./include/arpcache.h	/^	struct list_head list;$/;"	m	struct:cached_pkt	typeref:struct:cached_pkt::list_head
list	./include/base.h	/^	struct list_head list;		\/\/ list node used to link all interfaces$/;"	m	struct:__anon4	typeref:struct:__anon4::list_head
list	./include/rtable.h	/^	struct list_head list;$/;"	m	struct:__anon5	typeref:struct:__anon5::list_head
list	./include/tcp_sock.h	/^	struct list_head list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
list	./include/tcp_timer.h	/^	struct list_head list;$/;"	m	struct:tcp_timer	typeref:struct:tcp_timer::list_head
list_add_head	./include/list.h	/^static inline void list_add_head(struct list_head *new, struct list_head *head)$/;"	f
list_add_tail	./include/list.h	/^static inline void list_add_tail(struct list_head *new, struct list_head *head)$/;"	f
list_delete_entry	./include/list.h	/^static inline void list_delete_entry(struct list_head *entry)$/;"	f
list_empty	./include/list.h	12;"	d
list_entry	./include/list.h	15;"	d
list_for_each_entry	./include/list.h	19;"	d
list_for_each_entry_safe	./include/list.h	25;"	d
list_head	./include/list.h	/^struct list_head {$/;"	s
list_insert	./include/list.h	/^static inline void list_insert(struct list_head *new,$/;"	f
listen_queue	./include/tcp_sock.h	/^	struct list_head listen_queue;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
listen_table	./include/tcp_hash.h	/^	struct list_head listen_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
load_rtable_from_kernel	rtable_internal.c	/^void load_rtable_from_kernel()$/;"	f
local	./include/tcp_sock.h	/^	struct sock_addr local;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::sock_addr
lock	./include/arpcache.h	/^	pthread_mutex_t lock;				\/\/ each operation on arp cache should apply the lock first$/;"	m	struct:__anon2
lock	./include/async_wait.h	/^	pthread_mutex_t lock;$/;"	m	struct:async_wait
lock	./include/synch_wait.h	/^	pthread_mutex_t lock;		\/\/ mutex lock$/;"	m	struct:synch_wait
log	./include/log.h	25;"	d
log_it	./include/log.h	17;"	d
log_it	./include/log.h	21;"	d
log_level	./include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	g
log_level_str	./include/log.h	/^static const char *log_level_str[] = { "DEBUG", "INFO", "WARNING", "ERROR" };$/;"	v
longest_prefix_match	ip.c	/^rt_entry_t *longest_prefix_match(u32 dst)$/;"	f
mac	./include/arpcache.h	/^	u8 mac[ETH_ALEN];	\/\/ mac address$/;"	m	struct:arp_cache_entry
mac	./include/base.h	/^	u8	mac[ETH_ALEN];			\/\/ mac address of this interface$/;"	m	struct:__anon4
main	main.c	/^int main(int argc, char **argv)$/;"	f
mask	./include/base.h	/^	u32 mask;					\/\/ ip mask of this interface$/;"	m	struct:__anon4
mask	./include/rtable.h	/^	u32 mask;				\/\/ network mask of dest$/;"	m	struct:__anon5
max	tcp_in.c	67;"	d	file:
min	./include/ring_buffer.h	53;"	d
min	tcp_out.c	135;"	d	file:
min3	tcp_out.c	136;"	d	file:
name	./include/base.h	/^	char name[16];				\/\/ name of this interface$/;"	m	struct:__anon4
new_rt_entry	rtable.c	/^rt_entry_t *new_rt_entry(u32 dest, u32 mask, u32 gw, iface_info_t *iface)$/;"	f
next	./include/list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
nifs	./include/base.h	/^	int nifs;						\/\/ number of interfaces$/;"	m	struct:__anon3
nlmsg_hdr	rtable_internal.c	/^	struct nlmsghdr nlmsg_hdr;$/;"	m	struct:__anon1	typeref:struct:__anon1::nlmsghdr	file:
notified	./include/async_wait.h	/^	int notified;$/;"	m	struct:async_wait
notified	./include/synch_wait.h	/^	int notified;				\/\/ whether ready to read\/write$/;"	m	struct:synch_wait
off	./include/tcp.h	/^	u8 off:4;			\/\/ data offset$/;"	m	struct:tcphdr
open_device	main.c	/^int open_device(const char *dname)$/;"	f
packet	./include/arpcache.h	/^	char *packet;			\/\/ packet$/;"	m	struct:cached_pkt
packet_to_ether_arp	./include/arp.h	/^static inline struct ether_arp *packet_to_ether_arp(const char *packet)$/;"	f
packet_to_ip_hdr	./include/ip.h	/^static inline struct iphdr *packet_to_ip_hdr(const char *packet)$/;"	f
packet_to_tcp_hdr	./include/tcp.h	/^static inline struct tcphdr *packet_to_tcp_hdr(char *packet)$/;"	f
parent	./include/tcp_sock.h	/^	struct tcp_sock *parent;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::tcp_sock
parse_routing_info	rtable_internal.c	/^static int parse_routing_info(char *buf, int len)$/;"	f	file:
payload	./include/tcp.h	/^	char *payload;		\/\/ pointer to tcp data$/;"	m	struct:tcp_cb
peer	./include/tcp_sock.h	/^	struct sock_addr peer;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::sock_addr
pl_len	./include/tcp.h	/^	int pl_len;		\/\/ the length of tcp data$/;"	m	struct:tcp_cb
port	./include/tcp_sock.h	/^	u16 port;$/;"	m	struct:sock_addr
prev	./include/list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
print_rtable	rtable.c	/^void print_rtable()$/;"	f
protocol	./include/ip.h	/^    u8 protocol;						\/\/ upper layer protocol, e.g. icmp, tcp, udp $/;"	m	struct:iphdr
rcv_buf	./include/tcp_sock.h	/^	struct ring_buffer *rcv_buf;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::ring_buffer
rcv_nxt	./include/tcp_sock.h	/^	u32 rcv_nxt;$/;"	m	struct:tcp_sock
rcv_wnd	./include/tcp_sock.h	/^	u16 rcv_wnd;$/;"	m	struct:tcp_sock
read_iface_info	main.c	/^int read_iface_info(iface_info_t *iface)$/;"	f
read_ring_buffer	./include/ring_buffer.h	/^static inline int read_ring_buffer(struct ring_buffer *rbuf, char *buf, int size)$/;"	f
ref_cnt	./include/tcp_sock.h	/^	int ref_cnt;$/;"	m	struct:tcp_sock
remove_rt_entry	rtable.c	/^void remove_rt_entry(rt_entry_t *entry)$/;"	f
req_list	./include/arpcache.h	/^	struct list_head req_list;			\/\/ the pending packet list$/;"	m	struct:__anon2	typeref:struct:__anon2::list_head
retries	./include/arpcache.h	/^	int retries;			\/\/ number of retries$/;"	m	struct:arp_req
ring_buffer	./include/ring_buffer.h	/^struct ring_buffer {$/;"	s
ring_buffer_empty	./include/ring_buffer.h	/^static inline int ring_buffer_empty(struct ring_buffer *rbuf)$/;"	f
ring_buffer_free	./include/ring_buffer.h	/^static inline int ring_buffer_free(struct ring_buffer *rbuf)$/;"	f
ring_buffer_full	./include/ring_buffer.h	/^static inline int ring_buffer_full(struct ring_buffer *rbuf)$/;"	f
ring_buffer_used	./include/ring_buffer.h	/^static inline int ring_buffer_used(struct ring_buffer *rbuf)$/;"	f
route_request	rtable_internal.c	/^} route_request;$/;"	t	typeref:struct:__anon1	file:
rt_entry_t	./include/rtable.h	/^} rt_entry_t;$/;"	t	typeref:struct:__anon5
rt_msg	rtable_internal.c	/^	struct rtmsg rt_msg;$/;"	m	struct:__anon1	typeref:struct:__anon1::rtmsg	file:
rtable	rtable.c	/^struct list_head rtable;$/;"	v	typeref:struct:list_head
run_application	main.c	/^static void run_application(const char *basename, char **args, int n)$/;"	f	file:
rwnd	./include/tcp.h	/^	u16 rwnd;			\/\/ receiving window$/;"	m	struct:tcphdr
rwnd	./include/tcp.h	/^	u32 rwnd;		\/\/ receiving window in tcp header$/;"	m	struct:tcp_cb
saddr	./include/ip.h	/^    u32 saddr;							\/\/ source ip address$/;"	m	struct:iphdr
saddr	./include/tcp.h	/^	u32 saddr;		\/\/ source addr of the packet$/;"	m	struct:tcp_cb
sent	./include/arpcache.h	/^	time_t sent;			\/\/ last time when arp request is sent$/;"	m	struct:arp_req
seq	./include/tcp.h	/^	u32 seq;			\/\/ sequence number$/;"	m	struct:tcphdr
seq	./include/tcp.h	/^	u32 seq;		\/\/ sequence number in tcp header$/;"	m	struct:tcp_cb
seq_end	./include/tcp.h	/^	u32 seq_end;		\/\/ seq + (SYN|FIN) + len(payload)$/;"	m	struct:tcp_cb
size	./include/ring_buffer.h	/^	int size;$/;"	m	struct:ring_buffer
sk_dip	./include/tcp_sock.h	30;"	d
sk_dport	./include/tcp_sock.h	31;"	d
sk_sip	./include/tcp_sock.h	28;"	d
sk_sport	./include/tcp_sock.h	29;"	d
sleep	./include/async_wait.h	/^	int sleep;$/;"	m	struct:async_wait
sleep	./include/synch_wait.h	/^	int sleep;					\/\/ whether others are waiting$/;"	m	struct:synch_wait
sleep_on	./include/async_wait.h	/^static inline int sleep_on(struct async_wait *wait)$/;"	f
sleep_on	./include/synch_wait.h	/^static inline int sleep_on(struct synch_wait *wait)$/;"	f
snd_nxt	./include/tcp_sock.h	/^	u32 snd_nxt;$/;"	m	struct:tcp_sock
snd_una	./include/tcp_sock.h	/^	u32 snd_una;$/;"	m	struct:tcp_sock
snd_wnd	./include/tcp_sock.h	/^	u16 snd_wnd;$/;"	m	struct:tcp_sock
sock_addr	./include/tcp_sock.h	/^struct sock_addr {$/;"	s
sport	./include/tcp.h	/^	u16 sport;		\/\/ dest addr of the packet$/;"	m	struct:tcp_cb
sport	./include/tcp.h	/^	u16 sport;		\/\/ source port $/;"	m	struct:tcphdr
state	./include/tcp_sock.h	/^	int state;$/;"	m	struct:tcp_sock
synch_wait	./include/synch_wait.h	/^struct synch_wait {$/;"	s
tail	./include/ring_buffer.h	/^	int tail;		\/\/ write from tail$/;"	m	struct:ring_buffer
tcp	./include/tcp.h	/^	struct tcphdr *tcp;		\/\/ pointer to tcp header$/;"	m	struct:tcp_cb	typeref:struct:tcp_cb::tcphdr
tcp_bind_hash	tcp_sock.c	/^static int tcp_bind_hash(struct tcp_sock *tsk)$/;"	f	file:
tcp_bind_sock_table	tcp_sock.c	18;"	d	file:
tcp_bind_unhash	tcp_sock.c	/^void tcp_bind_unhash(struct tcp_sock *tsk)$/;"	f
tcp_cb	./include/tcp.h	/^struct tcp_cb {$/;"	s
tcp_cb_init	tcp.c	/^void tcp_cb_init(struct iphdr *ip, struct tcphdr *tcp, struct tcp_cb *cb)$/;"	f
tcp_checksum	./include/tcp.h	/^static inline u16 tcp_checksum(struct iphdr *ip, struct tcphdr *tcp)$/;"	f
tcp_client	tcp_apps.c	/^void *tcp_client(void *arg)$/;"	f
tcp_copy_flags_to_str	tcp.c	/^void tcp_copy_flags_to_str(u8 flags, char buf[32])$/;"	f
tcp_established_sock_table	tcp_sock.c	16;"	d	file:
tcp_get_port	tcp_sock.c	/^static u16 tcp_get_port()$/;"	f	file:
tcp_hash	tcp_sock.c	/^int tcp_hash(struct tcp_sock *tsk)$/;"	f
tcp_hash_function	./include/tcp_hash.h	/^static inline int tcp_hash_function(u32 saddr, u32 daddr, u16 sport, u16 dport)$/;"	f
tcp_hash_table	./include/tcp_hash.h	/^struct tcp_hash_table {$/;"	s
tcp_init_hdr	tcp_out.c	/^static void tcp_init_hdr(struct tcphdr *tcp, u16 sport, u16 dport, u32 seq, u32 ack,$/;"	f	file:
tcp_listen_sock_table	tcp_sock.c	17;"	d	file:
tcp_new_iss	tcp.c	/^u32 tcp_new_iss()$/;"	f
tcp_port_in_use	tcp_sock.c	/^static int tcp_port_in_use(u16 sport)$/;"	f	file:
tcp_process	tcp_in.c	/^void tcp_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_scan_timer_list	tcp_timer.c	/^void tcp_scan_timer_list()$/;"	f
tcp_send_control_packet	tcp_out.c	/^void tcp_send_control_packet(struct tcp_sock *tsk, u8 flags)$/;"	f
tcp_send_data	tcp_out.c	/^int tcp_send_data(struct tcp_sock *tsk, char *buf, int len)$/;"	f
tcp_send_packet	tcp_out.c	/^void tcp_send_packet(struct tcp_sock *tsk, char *packet, int len) $/;"	f
tcp_send_reset	tcp_out.c	/^void tcp_send_reset(struct tcp_cb *cb)$/;"	f
tcp_server	tcp_apps.c	/^void *tcp_server(void *arg)$/;"	f
tcp_set_state	tcp_sock.c	/^inline void tcp_set_state(struct tcp_sock *tsk, int state)$/;"	f
tcp_set_timewait_timer	tcp_timer.c	/^void tcp_set_timewait_timer(struct tcp_sock *tsk)$/;"	f
tcp_sock	./include/tcp_sock.h	/^struct tcp_sock {$/;"	s
tcp_sock_accept	tcp_sock.c	/^struct tcp_sock *tcp_sock_accept(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_dequeue	tcp_sock.c	/^inline struct tcp_sock *tcp_sock_accept_dequeue(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_enqueue	tcp_sock.c	/^inline void tcp_sock_accept_enqueue(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_queue_full	tcp_sock.c	/^inline int tcp_sock_accept_queue_full(struct tcp_sock *tsk)$/;"	f
tcp_sock_bind	tcp_sock.c	/^int tcp_sock_bind(struct tcp_sock *tsk, struct sock_addr *skaddr)$/;"	f
tcp_sock_clear_listen_queue	tcp_sock.c	/^static void tcp_sock_clear_listen_queue(struct tcp_sock *tsk)$/;"	f	file:
tcp_sock_close	tcp_sock.c	/^void tcp_sock_close(struct tcp_sock *tsk)$/;"	f
tcp_sock_connect	tcp_sock.c	/^int tcp_sock_connect(struct tcp_sock *tsk, struct sock_addr *skaddr)$/;"	f
tcp_sock_inc_ref_cnt	./include/tcp_sock.h	/^static inline void tcp_sock_inc_ref_cnt(struct tcp_sock *tsk)$/;"	f
tcp_sock_listen	tcp_sock.c	/^int tcp_sock_listen(struct tcp_sock *tsk, int backlog)$/;"	f
tcp_sock_lookup	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup(struct tcp_cb *cb)$/;"	f
tcp_sock_lookup_established	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup_established(u32 saddr, u32 daddr, u16 sport, u16 dport)$/;"	f
tcp_sock_lookup_listen	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup_listen(u32 saddr, u16 sport)$/;"	f
tcp_sock_set_sport	tcp_sock.c	/^static int tcp_sock_set_sport(struct tcp_sock *tsk, u16 port)$/;"	f	file:
tcp_sock_table	tcp_sock.c	/^struct tcp_hash_table tcp_sock_table;$/;"	v	typeref:struct:tcp_hash_table
tcp_state	./include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	g
tcp_state_closed	tcp_in.c	/^void tcp_state_closed(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_state_listen	tcp_in.c	/^void tcp_state_listen(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_state_str	tcp.c	/^const char *tcp_state_str[] = { "CLOSED", "LISTEN", "SYN_RECV",$/;"	v
tcp_state_syn_recv	tcp_in.c	/^void tcp_state_syn_recv(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_state_syn_sent	tcp_in.c	/^void tcp_state_syn_sent(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_state_to_str	./include/tcp.h	/^static inline const char *tcp_state_to_str(int state)$/;"	f
tcp_timer	./include/tcp_timer.h	/^struct tcp_timer {$/;"	s
tcp_timer_thread	tcp_timer.c	/^void *tcp_timer_thread(void *arg)$/;"	f
tcp_unhash	tcp_sock.c	/^void tcp_unhash(struct tcp_sock *tsk)$/;"	f
tcp_update_window	tcp_in.c	/^static inline void tcp_update_window(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
tcp_update_window_safe	tcp_in.c	/^static inline void tcp_update_window_safe(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
tcphdr	./include/tcp.h	/^struct tcphdr {$/;"	s
this_log_level	./include/log.h	/^static enum log_level this_log_level = DEBUG;$/;"	v	typeref:enum:log_level
thread	./include/arpcache.h	/^	pthread_t thread;					\/\/ the id of the arp cache sweeping thread$/;"	m	struct:__anon2
timeout	./include/tcp_timer.h	/^	int timeout;	\/\/ in micro second$/;"	m	struct:tcp_timer
timer_list	tcp_timer.c	/^static struct list_head timer_list;$/;"	v	typeref:struct:list_head	file:
timewait	./include/tcp_sock.h	/^	struct tcp_timer timewait;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::tcp_timer
timewait_to_tcp_sock	./include/tcp_timer.h	15;"	d
tos	./include/ip.h	/^    u8 tos;								\/\/ type of service (usually set to 0)$/;"	m	struct:iphdr
tot_len	./include/ip.h	/^    u16 tot_len;						\/\/ total length of ip data$/;"	m	struct:iphdr
ttl	./include/ip.h	/^    u8 ttl;								\/\/ ttl of ip packet$/;"	m	struct:iphdr
type	./include/icmp.h	/^	u8	type;				\/\/ type of icmp message$/;"	m	struct:icmphdr
type	./include/tcp_timer.h	/^	int type;	\/\/ now only support time-wait$/;"	m	struct:tcp_timer
u16	./include/types.h	/^typedef uint16_t u16;$/;"	t
u32	./include/types.h	/^typedef uint32_t u32;$/;"	t
u64	./include/types.h	/^typedef uint64_t u64;$/;"	t
u8	./include/types.h	/^typedef uint8_t u8;$/;"	t
urp	./include/tcp.h	/^	u16 urp;			\/\/ urgent pointer$/;"	m	struct:tcphdr
usage_and_exit	main.c	/^static void usage_and_exit(const char *basename)$/;"	f	file:
ustack_run	main.c	/^void ustack_run()$/;"	f
ustack_t	./include/base.h	/^} ustack_t;$/;"	t	typeref:struct:__anon3
valid	./include/arpcache.h	/^	int valid;			\/\/ whether this entry is valid (has not triggered the timeout)$/;"	m	struct:arp_cache_entry
version	./include/ip.h	/^    unsigned int version:4;				\/\/ ip version $/;"	m	struct:iphdr
wait_accept	./include/tcp_sock.h	/^	struct synch_wait *wait_accept;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_connect	./include/tcp_sock.h	/^	struct synch_wait *wait_connect;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_exit	./include/async_wait.h	/^static inline void wait_exit(struct async_wait *wait)$/;"	f
wait_exit	./include/synch_wait.h	/^static inline void wait_exit(struct synch_wait *wait)$/;"	f
wait_init	./include/async_wait.h	/^static inline void wait_init(struct async_wait *wait)$/;"	f
wait_init	./include/synch_wait.h	/^static inline void wait_init(struct synch_wait *wait)$/;"	f
wait_recv	./include/tcp_sock.h	/^	struct synch_wait *wait_recv;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_send	./include/tcp_sock.h	/^	struct synch_wait *wait_send;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wake_up	./include/async_wait.h	/^static inline int wake_up(struct async_wait *wait)$/;"	f
wake_up	./include/synch_wait.h	/^static inline int wake_up(struct synch_wait *wait)$/;"	f
write_ring_buffer	./include/ring_buffer.h	/^static inline void write_ring_buffer(struct ring_buffer *rbuf, char *buf, int size)$/;"	f
x2	./include/tcp.h	/^	u8 x2:4;			\/\/ (unused)$/;"	m	struct:tcphdr
